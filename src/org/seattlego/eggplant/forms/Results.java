/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package org.seattlego.eggplant.forms;

import java.awt.Color;
import java.awt.Component;
import java.awt.Insets;
import java.util.ArrayList;
import java.util.Arrays;
import javax.swing.JLabel;
import javax.swing.JTable;
import javax.swing.RowSorter;
import javax.swing.SortOrder;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import javax.swing.border.LineBorder;
import javax.swing.table.TableCellRenderer;
import javax.swing.table.TableRowSorter;
import org.jdesktop.beansbinding.*;
import org.jdesktop.observablecollections.ObservableCollections;
import org.jdesktop.observablecollections.ObservableList;
import org.jdesktop.swingbinding.JTableBinding;
import org.jdesktop.swingbinding.SwingBindings;
import org.seattlego.eggplant.interfaces.ITournament;
import org.seattlego.eggplant.model.FlaggedPlayerName;
import org.seattlego.eggplant.model.Game;
import org.seattlego.eggplant.model.GameResult;

/**
 *
 * @author Topsy
 */
public class Results extends EggplantForm {

    private ObservableList<Game> games;
    private BindingGroup bindings;
    //private Game selectedGame;

    // for tracking clicks
    private int mouseDownRow;
    private int mouseDownCol;
    
    /**
     * Creates new form Results
     */
    public Results() {
        initComponents();
        init();
    }
    
    private void init() {
        initRoundPane();
        roundPanel.add( roundPane );
        
        
        // Configure table
        tblGames.setAutoCreateColumnsFromModel( false ); // Preserves initial column widths.
        
        games = ObservableCollections.observableList( new ArrayList<Game>() );
        
        bindings = new BindingGroup();
        
        JTableBinding gamesBinding = SwingBindings.createJTableBinding( AutoBinding.UpdateStrategy.READ, games, tblGames, "gamesBinding");
        bindings.addBinding( gamesBinding );
        /*
        bindings.addBinding( Bindings.createAutoBinding( AutoBinding.UpdateStrategy.READ_WRITE,
                                    this,
                                    BeanProperty.create("selectedGame"), 
                                    tblGames,
                                    BeanProperty.create("selectedElement_IGNORE_ADJUSTING") ) );
        */
        JTableBinding.ColumnBinding columnBinding;
        columnBinding = gamesBinding.addColumnBinding(ELProperty.create("${tableNumberString}"));
        columnBinding.setColumnName("Table");
        columnBinding = gamesBinding.addColumnBinding(ELProperty.create("${whiteFlagged}"));
        columnBinding.setColumnName("White");
        columnBinding = gamesBinding.addColumnBinding(ELProperty.create("${blackFlagged}"));
        columnBinding.setColumnName("Black");
        columnBinding = gamesBinding.addColumnBinding(ELProperty.create("${resultString}"));
        columnBinding.setColumnName("Result");
        bindings.bind();
        
        TableRowSorter trsGames = new TableRowSorter( tblGames.getModel() );
        tblGames.setRowSorter( trsGames );
        
        RowSorter.SortKey defaultTableSort = new RowSorter.SortKey( 0 , SortOrder.ASCENDING );
        trsGames.setSortKeys( Arrays.asList( defaultTableSort ) );
        
        
        //
        
    }
    
    @Override
    protected void selectedRoundChanged() {
        updateControls();
    }
    
    
    @Override
    public void setTournament( ITournament t ) {
        super.setTournament( t );
        roundPane.setTournament( t );
    }
    
    @Override
    protected void updateControls() {
        // Pull the data for the current round.
        int currentRoundIndex = roundPane.getRoundIndex();
        
        games.clear();
        games.addAll( tournament.getGames( currentRoundIndex ) );
    }    
    /*
    public Game getSelectedGame() { return selectedGame; }
    public void setSelectedGame( Game g ) {
        Game old = selectedGame;
        selectedGame = g;
        firePropertyChange("selectedAlbum", old, getSelectedGame() );
    }
    */
    

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        roundPanel = new javax.swing.JPanel();
        scpGames = new javax.swing.JScrollPane();
        tblGames = new javax.swing.JTable();

        roundPanel.setLayout(new javax.swing.BoxLayout(roundPanel, javax.swing.BoxLayout.LINE_AXIS));

        tblGames.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "Table", "White", "Black", "Result"
            }
        ) {
            Class[] types = new Class [] {
                java.lang.Integer.class, java.lang.Object.class, java.lang.Object.class, java.lang.String.class
            };
            boolean[] canEdit = new boolean [] {
                false, false, false, false
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        tblGames.setRowHeight(20);
        tblGames.setRowSelectionAllowed(false);
        tblGames.getTableHeader().setReorderingAllowed(false);
        tblGames.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                tblGamesMouseClicked(evt);
            }
            public void mousePressed(java.awt.event.MouseEvent evt) {
                tblGamesMousePressed(evt);
            }
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                tblGamesMouseReleased(evt);
            }
        });
        scpGames.setViewportView(tblGames);
        if (tblGames.getColumnModel().getColumnCount() > 0) {
            tblGames.getColumnModel().getColumn(0).setPreferredWidth(10);
            tblGames.getColumnModel().getColumn(1).setPreferredWidth(200);
            tblGames.getColumnModel().getColumn(1).setCellRenderer(new ResultsTableCellRenderer());
            tblGames.getColumnModel().getColumn(2).setPreferredWidth(200);
            tblGames.getColumnModel().getColumn(2).setCellRenderer(new ResultsTableCellRenderer());
            tblGames.getColumnModel().getColumn(3).setPreferredWidth(50);
        }

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(roundPanel, javax.swing.GroupLayout.PREFERRED_SIZE, 154, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(scpGames, javax.swing.GroupLayout.DEFAULT_SIZE, 577, Short.MAX_VALUE)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(scpGames)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(roundPanel, javax.swing.GroupLayout.PREFERRED_SIZE, 80, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(0, 411, Short.MAX_VALUE)))
                .addContainerGap())
        );
    }// </editor-fold>//GEN-END:initComponents

    private void tblGamesMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_tblGamesMouseClicked
        /*
        // Identify clicked cell, update game result accordingly.
        int col = tblGames.columnAtPoint(evt.getPoint());
        
        Game g = selectedGame;
        
        // Map the row to a game.
        // TODO - ick, ick, ick! Literal strings! Need a better way of identifying columns.
        switch ( tblGames.getColumnName( col ) ) {
            case "White":
                if ( g.getResult() == GameResult.WHITE ) {
                    g.setResult( GameResult.UNKNOWN );
                } else {
                    g.setResult( GameResult.WHITE );
                }
                break;
            case "Black":
                if ( g.getResult() == GameResult.BLACK ) {
                    g.setResult( GameResult.UNKNOWN );
                } else {
                    g.setResult( GameResult.BLACK );
                }
                break;
            case "Result":
                g.setResult( g.getResult().getNext() );
                break;
            default:
                // no action
                return;
        }
        
        // Workaround
        // Table will not update for this change as the ObservableList has not changed, so we change it.
        int index = games.indexOf( g );
        games.remove( g );
        games.add( index, g );
        //
        
        tournament.setChangedSinceLastSave(true);
        // Scoring info must be recalculated.
        tournament.setScoringValidity( false );
                */
    }//GEN-LAST:event_tblGamesMouseClicked

    private void tblGamesMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_tblGamesMousePressed
        mouseDownRow = tblGames.rowAtPoint(evt.getPoint());
        mouseDownCol = tblGames.columnAtPoint(evt.getPoint());
    }//GEN-LAST:event_tblGamesMousePressed

    private void tblGamesMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_tblGamesMouseReleased
        if ( ( mouseDownRow != tblGames.rowAtPoint(evt.getPoint()) ) ||
             ( mouseDownCol != tblGames.columnAtPoint(evt.getPoint()) ) ) {
            mouseDownRow = -1;
            mouseDownCol = -1;
            return;
        }

        Game selectedGame = games.get( tblGames.convertRowIndexToModel( mouseDownRow ) );
        
        // Map the row to a game.
        // TODO - ick, ick, ick! Literal strings! Need a better way of identifying columns.
        switch ( tblGames.getColumnName( mouseDownCol ) ) {
            case "White":
                if ( selectedGame.getResult() == GameResult.WHITE ) {
                    selectedGame.setResult( GameResult.UNKNOWN );
                } else {
                    selectedGame.setResult( GameResult.WHITE );
                }
                break;
            case "Black":
                if ( selectedGame.getResult() == GameResult.BLACK ) {
                    selectedGame.setResult( GameResult.UNKNOWN );
                } else {
                    selectedGame.setResult( GameResult.BLACK );
                }
                break;
            case "Result":
                selectedGame.setResult( selectedGame.getResult().getNext() );
                break;
            default:
                // no action
                return;
        }
        
        // Workaround
        // Table will not update for this change as the ObservableList has not changed, so we change it.
        //int index = games.indexOf( selectedGame );
        games.remove( selectedGame );
        games.add( selectedGame );
        //tblGames.getRowSorter()
        //
        
        tournament.setChangedSinceLastSave(true);
        // Scoring info must be recalculated.
        tournament.setScoringValidity( false );
        
        mouseDownRow = -1;
        mouseDownCol = -1;
        
    }//GEN-LAST:event_tblGamesMouseReleased

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel roundPanel;
    private javax.swing.JScrollPane scpGames;
    private javax.swing.JTable tblGames;
    // End of variables declaration//GEN-END:variables
}


class ResultsTableCellRenderer extends JLabel implements TableCellRenderer {
    
    private final Color BORDER_COLOR = new Color( 180, 200, 180 );
            
    // This method is called each time a cell in a column
    // using this renderer needs to be rendered.
    @Override
    public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int rowIndex, int colIndex) {
        if ( value == null ) {
            return this;
        }
            
        FlaggedPlayerName typedValue = (FlaggedPlayerName) value;
        
        if ( typedValue.isWinner ) {
            
            this.setBorder( new CompoundBorder( new LineBorder( BORDER_COLOR, 3 ),
                                                new EmptyBorder(new Insets(1,1,1,1)) )
                                                 );
        } else {
            this.setBorder( new EmptyBorder(new Insets(4,4,4,4)) );
        }
        //setForeground( Color.BLACK );
        //setFont( new Font("Dialog", Font.PLAIN, 12 ) );
        setText( value.toString() );

        return this;
    }
}
